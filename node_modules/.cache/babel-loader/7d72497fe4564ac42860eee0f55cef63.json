{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrayExpression = arrayExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.binaryExpression = binaryExpression;\nexports.interpreterDirective = interpreterDirective;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.blockStatement = blockStatement;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports.labeledStatement = labeledStatement;\nexports.stringLiteral = stringLiteral;\nexports.numericLiteral = numericLiteral;\nexports.nullLiteral = nullLiteral;\nexports.booleanLiteral = booleanLiteral;\nexports.regExpLiteral = regExpLiteral;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.newExpression = newExpression;\nexports.program = program;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectProperty = objectProperty;\nexports.restElement = restElement;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.thisExpression = thisExpression;\nexports.throwStatement = throwStatement;\nexports.tryStatement = tryStatement;\nexports.unaryExpression = unaryExpression;\nexports.updateExpression = updateExpression;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.assignmentPattern = assignmentPattern;\nexports.arrayPattern = arrayPattern;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.classBody = classBody;\nexports.classExpression = classExpression;\nexports.classDeclaration = classDeclaration;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportSpecifier = exportSpecifier;\nexports.forOfStatement = forOfStatement;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.metaProperty = metaProperty;\nexports.classMethod = classMethod;\nexports.objectPattern = objectPattern;\nexports.spreadElement = spreadElement;\nexports.super = _super;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.yieldExpression = yieldExpression;\nexports.awaitExpression = awaitExpression;\nexports.import = _import;\nexports.bigIntLiteral = bigIntLiteral;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.optionalCallExpression = optionalCallExpression;\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.classImplements = classImplements;\nexports.declareClass = declareClass;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareVariable = declareVariable;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declaredPredicate = declaredPredicate;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.variance = variance;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.enumDeclaration = enumDeclaration;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumNumberBody = enumNumberBody;\nexports.enumStringBody = enumStringBody;\nexports.enumSymbolBody = enumSymbolBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringMember = enumStringMember;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXText = exports.jsxText = jsxText;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.noop = noop;\nexports.placeholder = placeholder;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.bindExpression = bindExpression;\nexports.classProperty = classProperty;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classPrivateMethod = classPrivateMethod;\nexports.importAttribute = importAttribute;\nexports.decorator = decorator;\nexports.doExpression = doExpression;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.privateName = privateName;\nexports.recordExpression = recordExpression;\nexports.tupleExpression = tupleExpression;\nexports.decimalLiteral = decimalLiteral;\nexports.staticBlock = staticBlock;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.numberLiteral = NumberLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restProperty = RestProperty;\nexports.spreadProperty = SpreadProperty;\n\nvar _builder = _interopRequireDefault(require(\"../builder\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction arrayExpression(elements) {\n  return (0, _builder.default).apply(void 0, [\"ArrayExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction assignmentExpression(operator, left, right) {\n  return (0, _builder.default).apply(void 0, [\"AssignmentExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction binaryExpression(operator, left, right) {\n  return (0, _builder.default).apply(void 0, [\"BinaryExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction interpreterDirective(value) {\n  return (0, _builder.default).apply(void 0, [\"InterpreterDirective\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction directive(value) {\n  return (0, _builder.default).apply(void 0, [\"Directive\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction directiveLiteral(value) {\n  return (0, _builder.default).apply(void 0, [\"DirectiveLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction blockStatement(body, directives) {\n  return (0, _builder.default).apply(void 0, [\"BlockStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction breakStatement(label) {\n  return (0, _builder.default).apply(void 0, [\"BreakStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction callExpression(callee, _arguments) {\n  return (0, _builder.default).apply(void 0, [\"CallExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction catchClause(param, body) {\n  return (0, _builder.default).apply(void 0, [\"CatchClause\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction conditionalExpression(test, consequent, alternate) {\n  return (0, _builder.default).apply(void 0, [\"ConditionalExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction continueStatement(label) {\n  return (0, _builder.default).apply(void 0, [\"ContinueStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction debuggerStatement() {\n  return (0, _builder.default).apply(void 0, [\"DebuggerStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction doWhileStatement(test, body) {\n  return (0, _builder.default).apply(void 0, [\"DoWhileStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction emptyStatement() {\n  return (0, _builder.default).apply(void 0, [\"EmptyStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction expressionStatement(expression) {\n  return (0, _builder.default).apply(void 0, [\"ExpressionStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction file(program, comments, tokens) {\n  return (0, _builder.default).apply(void 0, [\"File\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction forInStatement(left, right, body) {\n  return (0, _builder.default).apply(void 0, [\"ForInStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction forStatement(init, test, update, body) {\n  return (0, _builder.default).apply(void 0, [\"ForStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction functionDeclaration(id, params, body, generator, async) {\n  return (0, _builder.default).apply(void 0, [\"FunctionDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction functionExpression(id, params, body, generator, async) {\n  return (0, _builder.default).apply(void 0, [\"FunctionExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction identifier(name) {\n  return (0, _builder.default).apply(void 0, [\"Identifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction ifStatement(test, consequent, alternate) {\n  return (0, _builder.default).apply(void 0, [\"IfStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction labeledStatement(label, body) {\n  return (0, _builder.default).apply(void 0, [\"LabeledStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction stringLiteral(value) {\n  return (0, _builder.default).apply(void 0, [\"StringLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction numericLiteral(value) {\n  return (0, _builder.default).apply(void 0, [\"NumericLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction nullLiteral() {\n  return (0, _builder.default).apply(void 0, [\"NullLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction booleanLiteral(value) {\n  return (0, _builder.default).apply(void 0, [\"BooleanLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction regExpLiteral(pattern, flags) {\n  return (0, _builder.default).apply(void 0, [\"RegExpLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction logicalExpression(operator, left, right) {\n  return (0, _builder.default).apply(void 0, [\"LogicalExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction memberExpression(object, property, computed, optional) {\n  return (0, _builder.default).apply(void 0, [\"MemberExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction newExpression(callee, _arguments) {\n  return (0, _builder.default).apply(void 0, [\"NewExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction program(body, directives, sourceType, interpreter) {\n  return (0, _builder.default).apply(void 0, [\"Program\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectExpression(properties) {\n  return (0, _builder.default).apply(void 0, [\"ObjectExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectMethod(kind, key, params, body, computed, generator, async) {\n  return (0, _builder.default).apply(void 0, [\"ObjectMethod\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectProperty(key, value, computed, shorthand, decorators) {\n  return (0, _builder.default).apply(void 0, [\"ObjectProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction restElement(argument) {\n  return (0, _builder.default).apply(void 0, [\"RestElement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction returnStatement(argument) {\n  return (0, _builder.default).apply(void 0, [\"ReturnStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction sequenceExpression(expressions) {\n  return (0, _builder.default).apply(void 0, [\"SequenceExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction parenthesizedExpression(expression) {\n  return (0, _builder.default).apply(void 0, [\"ParenthesizedExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction switchCase(test, consequent) {\n  return (0, _builder.default).apply(void 0, [\"SwitchCase\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction switchStatement(discriminant, cases) {\n  return (0, _builder.default).apply(void 0, [\"SwitchStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction thisExpression() {\n  return (0, _builder.default).apply(void 0, [\"ThisExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction throwStatement(argument) {\n  return (0, _builder.default).apply(void 0, [\"ThrowStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tryStatement(block, handler, finalizer) {\n  return (0, _builder.default).apply(void 0, [\"TryStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction unaryExpression(operator, argument, prefix) {\n  return (0, _builder.default).apply(void 0, [\"UnaryExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction updateExpression(operator, argument, prefix) {\n  return (0, _builder.default).apply(void 0, [\"UpdateExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction variableDeclaration(kind, declarations) {\n  return (0, _builder.default).apply(void 0, [\"VariableDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction variableDeclarator(id, init) {\n  return (0, _builder.default).apply(void 0, [\"VariableDeclarator\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction whileStatement(test, body) {\n  return (0, _builder.default).apply(void 0, [\"WhileStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction withStatement(object, body) {\n  return (0, _builder.default).apply(void 0, [\"WithStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction assignmentPattern(left, right) {\n  return (0, _builder.default).apply(void 0, [\"AssignmentPattern\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction arrayPattern(elements) {\n  return (0, _builder.default).apply(void 0, [\"ArrayPattern\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction arrowFunctionExpression(params, body, async) {\n  return (0, _builder.default).apply(void 0, [\"ArrowFunctionExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classBody(body) {\n  return (0, _builder.default).apply(void 0, [\"ClassBody\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classExpression(id, superClass, body, decorators) {\n  return (0, _builder.default).apply(void 0, [\"ClassExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classDeclaration(id, superClass, body, decorators) {\n  return (0, _builder.default).apply(void 0, [\"ClassDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction exportAllDeclaration(source) {\n  return (0, _builder.default).apply(void 0, [\"ExportAllDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction exportDefaultDeclaration(declaration) {\n  return (0, _builder.default).apply(void 0, [\"ExportDefaultDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction exportNamedDeclaration(declaration, specifiers, source) {\n  return (0, _builder.default).apply(void 0, [\"ExportNamedDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction exportSpecifier(local, exported) {\n  return (0, _builder.default).apply(void 0, [\"ExportSpecifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction forOfStatement(left, right, body, _await) {\n  return (0, _builder.default).apply(void 0, [\"ForOfStatement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction importDeclaration(specifiers, source) {\n  return (0, _builder.default).apply(void 0, [\"ImportDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction importDefaultSpecifier(local) {\n  return (0, _builder.default).apply(void 0, [\"ImportDefaultSpecifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction importNamespaceSpecifier(local) {\n  return (0, _builder.default).apply(void 0, [\"ImportNamespaceSpecifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction importSpecifier(local, imported) {\n  return (0, _builder.default).apply(void 0, [\"ImportSpecifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction metaProperty(meta, property) {\n  return (0, _builder.default).apply(void 0, [\"MetaProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classMethod(kind, key, params, body, computed, _static, generator, async) {\n  return (0, _builder.default).apply(void 0, [\"ClassMethod\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectPattern(properties) {\n  return (0, _builder.default).apply(void 0, [\"ObjectPattern\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction spreadElement(argument) {\n  return (0, _builder.default).apply(void 0, [\"SpreadElement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction _super() {\n  return (0, _builder.default).apply(void 0, [\"Super\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction taggedTemplateExpression(tag, quasi) {\n  return (0, _builder.default).apply(void 0, [\"TaggedTemplateExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction templateElement(value, tail) {\n  return (0, _builder.default).apply(void 0, [\"TemplateElement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction templateLiteral(quasis, expressions) {\n  return (0, _builder.default).apply(void 0, [\"TemplateLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction yieldExpression(argument, delegate) {\n  return (0, _builder.default).apply(void 0, [\"YieldExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction awaitExpression(argument) {\n  return (0, _builder.default).apply(void 0, [\"AwaitExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction _import() {\n  return (0, _builder.default).apply(void 0, [\"Import\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction bigIntLiteral(value) {\n  return (0, _builder.default).apply(void 0, [\"BigIntLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction exportNamespaceSpecifier(exported) {\n  return (0, _builder.default).apply(void 0, [\"ExportNamespaceSpecifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction optionalMemberExpression(object, property, computed, optional) {\n  return (0, _builder.default).apply(void 0, [\"OptionalMemberExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction optionalCallExpression(callee, _arguments, optional) {\n  return (0, _builder.default).apply(void 0, [\"OptionalCallExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction anyTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"AnyTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction arrayTypeAnnotation(elementType) {\n  return (0, _builder.default).apply(void 0, [\"ArrayTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction booleanTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"BooleanTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction booleanLiteralTypeAnnotation(value) {\n  return (0, _builder.default).apply(void 0, [\"BooleanLiteralTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction nullLiteralTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"NullLiteralTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classImplements(id, typeParameters) {\n  return (0, _builder.default).apply(void 0, [\"ClassImplements\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareClass(id, typeParameters, _extends, body) {\n  return (0, _builder.default).apply(void 0, [\"DeclareClass\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareFunction(id) {\n  return (0, _builder.default).apply(void 0, [\"DeclareFunction\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareInterface(id, typeParameters, _extends, body) {\n  return (0, _builder.default).apply(void 0, [\"DeclareInterface\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareModule(id, body, kind) {\n  return (0, _builder.default).apply(void 0, [\"DeclareModule\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareModuleExports(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"DeclareModuleExports\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareTypeAlias(id, typeParameters, right) {\n  return (0, _builder.default).apply(void 0, [\"DeclareTypeAlias\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareOpaqueType(id, typeParameters, supertype) {\n  return (0, _builder.default).apply(void 0, [\"DeclareOpaqueType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareVariable(id) {\n  return (0, _builder.default).apply(void 0, [\"DeclareVariable\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareExportDeclaration(declaration, specifiers, source) {\n  return (0, _builder.default).apply(void 0, [\"DeclareExportDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declareExportAllDeclaration(source) {\n  return (0, _builder.default).apply(void 0, [\"DeclareExportAllDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction declaredPredicate(value) {\n  return (0, _builder.default).apply(void 0, [\"DeclaredPredicate\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction existsTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"ExistsTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction functionTypeAnnotation(typeParameters, params, rest, returnType) {\n  return (0, _builder.default).apply(void 0, [\"FunctionTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction functionTypeParam(name, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"FunctionTypeParam\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction genericTypeAnnotation(id, typeParameters) {\n  return (0, _builder.default).apply(void 0, [\"GenericTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction inferredPredicate() {\n  return (0, _builder.default).apply(void 0, [\"InferredPredicate\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction interfaceExtends(id, typeParameters) {\n  return (0, _builder.default).apply(void 0, [\"InterfaceExtends\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction interfaceDeclaration(id, typeParameters, _extends, body) {\n  return (0, _builder.default).apply(void 0, [\"InterfaceDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction interfaceTypeAnnotation(_extends, body) {\n  return (0, _builder.default).apply(void 0, [\"InterfaceTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction intersectionTypeAnnotation(types) {\n  return (0, _builder.default).apply(void 0, [\"IntersectionTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction mixedTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"MixedTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction emptyTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"EmptyTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction nullableTypeAnnotation(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"NullableTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction numberLiteralTypeAnnotation(value) {\n  return (0, _builder.default).apply(void 0, [\"NumberLiteralTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction numberTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"NumberTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {\n  return (0, _builder.default).apply(void 0, [\"ObjectTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  return (0, _builder.default).apply(void 0, [\"ObjectTypeInternalSlot\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectTypeCallProperty(value) {\n  return (0, _builder.default).apply(void 0, [\"ObjectTypeCallProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectTypeIndexer(id, key, value, variance) {\n  return (0, _builder.default).apply(void 0, [\"ObjectTypeIndexer\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectTypeProperty(key, value, variance) {\n  return (0, _builder.default).apply(void 0, [\"ObjectTypeProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction objectTypeSpreadProperty(argument) {\n  return (0, _builder.default).apply(void 0, [\"ObjectTypeSpreadProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction opaqueType(id, typeParameters, supertype, impltype) {\n  return (0, _builder.default).apply(void 0, [\"OpaqueType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction qualifiedTypeIdentifier(id, qualification) {\n  return (0, _builder.default).apply(void 0, [\"QualifiedTypeIdentifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction stringLiteralTypeAnnotation(value) {\n  return (0, _builder.default).apply(void 0, [\"StringLiteralTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction stringTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"StringTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction symbolTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"SymbolTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction thisTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"ThisTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tupleTypeAnnotation(types) {\n  return (0, _builder.default).apply(void 0, [\"TupleTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction typeofTypeAnnotation(argument) {\n  return (0, _builder.default).apply(void 0, [\"TypeofTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction typeAlias(id, typeParameters, right) {\n  return (0, _builder.default).apply(void 0, [\"TypeAlias\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction typeAnnotation(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction typeCastExpression(expression, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TypeCastExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction typeParameter(bound, _default, variance) {\n  return (0, _builder.default).apply(void 0, [\"TypeParameter\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction typeParameterDeclaration(params) {\n  return (0, _builder.default).apply(void 0, [\"TypeParameterDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction typeParameterInstantiation(params) {\n  return (0, _builder.default).apply(void 0, [\"TypeParameterInstantiation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction unionTypeAnnotation(types) {\n  return (0, _builder.default).apply(void 0, [\"UnionTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction variance(kind) {\n  return (0, _builder.default).apply(void 0, [\"Variance\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction voidTypeAnnotation() {\n  return (0, _builder.default).apply(void 0, [\"VoidTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumDeclaration(id, body) {\n  return (0, _builder.default).apply(void 0, [\"EnumDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumBooleanBody(members) {\n  return (0, _builder.default).apply(void 0, [\"EnumBooleanBody\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumNumberBody(members) {\n  return (0, _builder.default).apply(void 0, [\"EnumNumberBody\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumStringBody(members) {\n  return (0, _builder.default).apply(void 0, [\"EnumStringBody\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumSymbolBody(members) {\n  return (0, _builder.default).apply(void 0, [\"EnumSymbolBody\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumBooleanMember(id) {\n  return (0, _builder.default).apply(void 0, [\"EnumBooleanMember\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumNumberMember(id, init) {\n  return (0, _builder.default).apply(void 0, [\"EnumNumberMember\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumStringMember(id, init) {\n  return (0, _builder.default).apply(void 0, [\"EnumStringMember\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction enumDefaultedMember(id) {\n  return (0, _builder.default).apply(void 0, [\"EnumDefaultedMember\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxAttribute(name, value) {\n  return (0, _builder.default).apply(void 0, [\"JSXAttribute\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxClosingElement(name) {\n  return (0, _builder.default).apply(void 0, [\"JSXClosingElement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxElement(openingElement, closingElement, children, selfClosing) {\n  return (0, _builder.default).apply(void 0, [\"JSXElement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxEmptyExpression() {\n  return (0, _builder.default).apply(void 0, [\"JSXEmptyExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxExpressionContainer(expression) {\n  return (0, _builder.default).apply(void 0, [\"JSXExpressionContainer\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxSpreadChild(expression) {\n  return (0, _builder.default).apply(void 0, [\"JSXSpreadChild\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxIdentifier(name) {\n  return (0, _builder.default).apply(void 0, [\"JSXIdentifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxMemberExpression(object, property) {\n  return (0, _builder.default).apply(void 0, [\"JSXMemberExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxNamespacedName(namespace, name) {\n  return (0, _builder.default).apply(void 0, [\"JSXNamespacedName\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxOpeningElement(name, attributes, selfClosing) {\n  return (0, _builder.default).apply(void 0, [\"JSXOpeningElement\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxSpreadAttribute(argument) {\n  return (0, _builder.default).apply(void 0, [\"JSXSpreadAttribute\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxText(value) {\n  return (0, _builder.default).apply(void 0, [\"JSXText\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  return (0, _builder.default).apply(void 0, [\"JSXFragment\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxOpeningFragment() {\n  return (0, _builder.default).apply(void 0, [\"JSXOpeningFragment\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction jsxClosingFragment() {\n  return (0, _builder.default).apply(void 0, [\"JSXClosingFragment\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction noop() {\n  return (0, _builder.default).apply(void 0, [\"Noop\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction placeholder(expectedNode, name) {\n  return (0, _builder.default).apply(void 0, [\"Placeholder\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction v8IntrinsicIdentifier(name) {\n  return (0, _builder.default).apply(void 0, [\"V8IntrinsicIdentifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction argumentPlaceholder() {\n  return (0, _builder.default).apply(void 0, [\"ArgumentPlaceholder\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction bindExpression(object, callee) {\n  return (0, _builder.default).apply(void 0, [\"BindExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classProperty(key, value, typeAnnotation, decorators, computed, _static) {\n  return (0, _builder.default).apply(void 0, [\"ClassProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction pipelineTopicExpression(expression) {\n  return (0, _builder.default).apply(void 0, [\"PipelineTopicExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction pipelineBareFunction(callee) {\n  return (0, _builder.default).apply(void 0, [\"PipelineBareFunction\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction pipelinePrimaryTopicReference() {\n  return (0, _builder.default).apply(void 0, [\"PipelinePrimaryTopicReference\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classPrivateProperty(key, value, decorators, _static) {\n  return (0, _builder.default).apply(void 0, [\"ClassPrivateProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction classPrivateMethod(kind, key, params, body, _static) {\n  return (0, _builder.default).apply(void 0, [\"ClassPrivateMethod\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction importAttribute(key, value) {\n  return (0, _builder.default).apply(void 0, [\"ImportAttribute\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction decorator(expression) {\n  return (0, _builder.default).apply(void 0, [\"Decorator\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction doExpression(body) {\n  return (0, _builder.default).apply(void 0, [\"DoExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction exportDefaultSpecifier(exported) {\n  return (0, _builder.default).apply(void 0, [\"ExportDefaultSpecifier\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction privateName(id) {\n  return (0, _builder.default).apply(void 0, [\"PrivateName\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction recordExpression(properties) {\n  return (0, _builder.default).apply(void 0, [\"RecordExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tupleExpression(elements) {\n  return (0, _builder.default).apply(void 0, [\"TupleExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction decimalLiteral(value) {\n  return (0, _builder.default).apply(void 0, [\"DecimalLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction staticBlock(body) {\n  return (0, _builder.default).apply(void 0, [\"StaticBlock\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsParameterProperty(parameter) {\n  return (0, _builder.default).apply(void 0, [\"TSParameterProperty\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsDeclareFunction(id, typeParameters, params, returnType) {\n  return (0, _builder.default).apply(void 0, [\"TSDeclareFunction\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsDeclareMethod(decorators, key, typeParameters, params, returnType) {\n  return (0, _builder.default).apply(void 0, [\"TSDeclareMethod\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsQualifiedName(left, right) {\n  return (0, _builder.default).apply(void 0, [\"TSQualifiedName\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSCallSignatureDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSConstructSignatureDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsPropertySignature(key, typeAnnotation, initializer) {\n  return (0, _builder.default).apply(void 0, [\"TSPropertySignature\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSMethodSignature\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsIndexSignature(parameters, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSIndexSignature\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsAnyKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSAnyKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsBooleanKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSBooleanKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsBigIntKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSBigIntKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsIntrinsicKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSIntrinsicKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsNeverKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSNeverKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsNullKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSNullKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsNumberKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSNumberKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsObjectKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSObjectKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsStringKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSStringKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsSymbolKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSSymbolKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsUndefinedKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSUndefinedKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsUnknownKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSUnknownKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsVoidKeyword() {\n  return (0, _builder.default).apply(void 0, [\"TSVoidKeyword\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsThisType() {\n  return (0, _builder.default).apply(void 0, [\"TSThisType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsFunctionType(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSFunctionType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsConstructorType(typeParameters, parameters, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSConstructorType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeReference(typeName, typeParameters) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeReference\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypePredicate(parameterName, typeAnnotation, asserts) {\n  return (0, _builder.default).apply(void 0, [\"TSTypePredicate\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeQuery(exprName) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeQuery\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeLiteral(members) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeLiteral\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsArrayType(elementType) {\n  return (0, _builder.default).apply(void 0, [\"TSArrayType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTupleType(elementTypes) {\n  return (0, _builder.default).apply(void 0, [\"TSTupleType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsOptionalType(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSOptionalType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsRestType(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSRestType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsNamedTupleMember(label, elementType, optional) {\n  return (0, _builder.default).apply(void 0, [\"TSNamedTupleMember\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsUnionType(types) {\n  return (0, _builder.default).apply(void 0, [\"TSUnionType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsIntersectionType(types) {\n  return (0, _builder.default).apply(void 0, [\"TSIntersectionType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  return (0, _builder.default).apply(void 0, [\"TSConditionalType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsInferType(typeParameter) {\n  return (0, _builder.default).apply(void 0, [\"TSInferType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsParenthesizedType(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSParenthesizedType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeOperator(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeOperator\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsIndexedAccessType(objectType, indexType) {\n  return (0, _builder.default).apply(void 0, [\"TSIndexedAccessType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsMappedType(typeParameter, typeAnnotation, nameType) {\n  return (0, _builder.default).apply(void 0, [\"TSMappedType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsLiteralType(literal) {\n  return (0, _builder.default).apply(void 0, [\"TSLiteralType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsExpressionWithTypeArguments(expression, typeParameters) {\n  return (0, _builder.default).apply(void 0, [\"TSExpressionWithTypeArguments\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsInterfaceDeclaration(id, typeParameters, _extends, body) {\n  return (0, _builder.default).apply(void 0, [\"TSInterfaceDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsInterfaceBody(body) {\n  return (0, _builder.default).apply(void 0, [\"TSInterfaceBody\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeAliasDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsAsExpression(expression, typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSAsExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeAssertion\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsEnumDeclaration(id, members) {\n  return (0, _builder.default).apply(void 0, [\"TSEnumDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsEnumMember(id, initializer) {\n  return (0, _builder.default).apply(void 0, [\"TSEnumMember\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsModuleDeclaration(id, body) {\n  return (0, _builder.default).apply(void 0, [\"TSModuleDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsModuleBlock(body) {\n  return (0, _builder.default).apply(void 0, [\"TSModuleBlock\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsImportType(argument, qualifier, typeParameters) {\n  return (0, _builder.default).apply(void 0, [\"TSImportType\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  return (0, _builder.default).apply(void 0, [\"TSImportEqualsDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsExternalModuleReference(expression) {\n  return (0, _builder.default).apply(void 0, [\"TSExternalModuleReference\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsNonNullExpression(expression) {\n  return (0, _builder.default).apply(void 0, [\"TSNonNullExpression\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsExportAssignment(expression) {\n  return (0, _builder.default).apply(void 0, [\"TSExportAssignment\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsNamespaceExportDeclaration(id) {\n  return (0, _builder.default).apply(void 0, [\"TSNamespaceExportDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeAnnotation(typeAnnotation) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeAnnotation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeParameterInstantiation(params) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeParameterInstantiation\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeParameterDeclaration(params) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeParameterDeclaration\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction tsTypeParameter(constraint, _default, name) {\n  return (0, _builder.default).apply(void 0, [\"TSTypeParameter\"].concat(Array.prototype.slice.call(arguments)));\n}\n\nfunction NumberLiteral() {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return (0, _builder.default).apply(void 0, [\"NumberLiteral\"].concat(args));\n}\n\nfunction RegexLiteral() {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return (0, _builder.default).apply(void 0, [\"RegexLiteral\"].concat(args));\n}\n\nfunction RestProperty() {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return (0, _builder.default).apply(void 0, [\"RestProperty\"].concat(args));\n}\n\nfunction SpreadProperty() {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  return (0, _builder.default).apply(void 0, [\"SpreadProperty\"].concat(args));\n}","map":null,"metadata":{},"sourceType":"script"}